<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=yes;" />

    <title>Concurrency Manager in Go</title>

    <link href='http://fonts.googleapis.com/css?family=Comfortaa:300' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,800,300' rel='stylesheet' type='text/css'>

    <script>
      window.addEventListener("load",function() {
        setTimeout(function(){
          window.scrollTo(0, 0);
        }, 0);
      });
    </script>

    <link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
  </head>

  <body id='body' class="blog blog_2013-06-07-Go_Manager blog_2013-06-07-Go_Manager_index">

    <a href='/' class='jpoz '>JPoz</a>
    <a href='/photos' class='jpoz_photos inactive'>&nbsp;</a>
    <div class='contacts '>
      <a target='_blank' href='http://github.com/jpoz' class='contact github'>&nbsp;</a>
      <a target='_blank' href='http://twitter.com/jpoz' class='contact twitter'>&nbsp;</a>
      <a target='_blank' href='http://instagram.com/jpoz' class='contact instagram'>&nbsp;</a>  
    </div>

    <div id='content'>
        <div class='blog'>
    <div class='header'>
      <h1>Concurrency Manager in Go</h1>
      <h4>Jun  7 2013</h4>
    </div>

    



    <article>
      <p>Sometimes Go is just too damn fast. I recently ran into a situation where I was making too many calls too quickly to a third party API. The calls were coming from many different parts of my application. I need one place I could send call that would manage their execution while rate limiting the calls to the API.</p>

<p>Originally stolen from <a href="http://michaelspeer.knome.net/2010/03/go-language-is-lovely.html">here</a>, I added in rate limiting (with bursting) and the ability to give a go routine to the manager and wait for it&#39;s completion.</p>

<p>Basic Usage:</p>

<pre><code data-language="go">package main

import "manager" // below

func main() {
  m := manager.New()

  for i := 0 ; i < 100 ; i++ {
    j := i
    m.Go(func(){
      time.Sleep( rand.Int63n( 1000000000 ) )
      fmt.Print( j , "\n" )

      // GoAndWait returns an chan error
      c := w.GoAndWait(func() (err error) {
        fmt.Print( j , " - started\n")      
        time.Sleep( rand.Int63n( 1000000000 ) )
        return
      })
      <- c
      fmt.Print( j , " - finished\n")
    })
 }
}

</code></pre>

<p>I love Go. Here&#39;s the code:</p>

<h3>manager.go</h3>

<pre><code data-language="go">package manager

import "sync"
import "time"

type Manager interface {
    Go(func())
    Wait()
}

type manager struct {
    lock    sync.Mutex
    running uint
    waiting uint
    wakeup  chan bool
    burst   uint
    timeout time.Duration
    limiter chan time.Time
}

func New() *manager {
    m := new(manager)
    m.limiter = nil
    m.burst = 0
    m.timeout = 0
    m.wakeup = make(chan bool)
    return m
}

func (m *manager) RateLimit(burst uint, timeout time.Duration) {
    m.lock.Lock()

    m.limiter = make(chan time.Time, burst)

    go func() {
        for t := range time.Tick(time.Millisecond * timeout) {
            m.limiter <- t
        }
    }()

    m.lock.Unlock()
    return
}

func (m *manager) Go(fn func()) {
    m.lock.Lock()
    m.running++
    m.lock.Unlock()

    go func() {
        if m.timeout != 0 {
            <-m.limiter
        }
        fn()

        m.lock.Lock()
        m.running--
        if (m.running == 0) && (m.waiting > 0) {
            oc := m.wakeup
            nc := make(chan bool)
            i := m.waiting
            go func() {
                for ; i > 0; i-- {
                    oc <- true
                }
            }()
            m.wakeup = nc
            m.waiting = 0
        }
        m.lock.Unlock()
    }()
}

func (m *manager) GoAndWait(fn func() error) chan error {
    m.lock.Lock()
    m.running++
    m.lock.Unlock()

    err_chan := make(chan error, 1)

    go func() {
        if m.timeout != 0 {
            <-m.limiter
        }
        err_chan <- fn()

        m.lock.Lock()
        m.running--
        if (m.running == 0) && (m.waiting > 0) {
            oc := m.wakeup
            nc := make(chan bool)
            i := m.waiting
            go func() {
                for ; i > 0; i-- {
                    oc <- true
                }
            }()
            m.wakeup = nc
            m.waiting = 0
        }
        m.lock.Unlock()
    }()

    return err_chan
}

func (m *manager) Wait() {
    wait := false

    m.lock.Lock()
    if m.running > 0 {
        m.waiting++
        wait = true
    }
    m.lock.Unlock()

    if wait {
        <-m.wakeup
    }
}
</code></pre>

    </article>

    <footer>
      Comments? <a href='http://twitter.com/jpoz'>@jpoz</a> on twitter!
    </footer>
  
  </div>


    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3441225-6']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
